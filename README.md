# Java-Multithreading-tutorials
A series of  tutorials on java multi-threading.

1) Creating threads by extending Thread or implementing Runnable and passing it to Thread constructor

2) volitile keyword - synchronizing variables for reads on multiple threads

3) synchronized methods - obtaining intrinsic lock on object for synchronizing both memory reads and writes

4) synchronized statements - a more flexible way of obtaining locks 

5) Thread pools - a way to reuse the threads, and reducing thread creation overhead

6) CountdownLatch - a way to gain some control over the execution of threads in thread pool

7) ArrayBlockingQueue - a simulation of consumer producer relationship with limited producer storage and possible product shortages

8) wait() and notify() with synchronized methods - a way of passing control between the threads

9) wait() and notify() with synchronized statements

10) ReentrantLocks - a more flexible way of obtaining a lock that goes beyond method or code block

11) Deadlock - two or more threads blocking each other execution due to each inability to obtain a required lock and a solution with             acquireLocks () method

12) Semaphores - a way to limit a number of parralel threds

13) Future and Callable interface - a way to receive a value back from running a background thread

14) Interrupting threads - stopping threads that run for too long

